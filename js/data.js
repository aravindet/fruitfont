class Storable extends EventTarget {
	constructor(key, defaultData) {
		super();
		this.key = key;
		this.load(defaultData);
	}

	save() {
		if (typeof this.data !== "undefined") {
			localStorage.setItem(this.key, JSON.stringify(this.data));
		} else {
			localStorage.removeItem(this.key);
		}
	}

	load(defaultData = {}) {
		const json = localStorage.getItem(this.key);
		this.data = json ? JSON.parse(json) : defaultData;
	}

	update(changes) {
		Object.assign(this.data, changes);
		this.save();
		this.dispatchEvent(new CustomEvent("change", this.data));
	}

	replace(data) {
		this.data = data;
		this.save();
		this.dispatchEvent(new CustomEvent("change", this.data));
	}
}

const fontDefaults = {
	charfirst: 32,
	charlast: 126,
	xmin: -3,
	ymin: -3,
	xmax: 12,
	ymax: 12,
};

class Font extends Storable {
	constructor(name) {
		super("font", { name, variantCount: 0, ...fontDefaults });
		this.variants = [];
		for (let i = 0; i < this.data.variantCount; i++) {
			this.variants.push(new Variant(i, this));
		}
	}

	addVariant() {
		const variant = new Variant(this.variants.length, this);
		this.variants.push(variant);
		this.update({ variantCount: this.variants.length });
	}
}

const variantDefaults = {
	ystep: 16,
};

class Variant extends Storable {
	constructor(index, font) {
		super(`variant_${index}`, variantDefaults);
		this.font = font;
		this.index = index;
		this.glyphs = [];
		for (let c = this.font.data.charfirst; c <= this.font.data.charlast; c++) {
			this.glyphs.push(new Glyph(c, this));
		}
	}
}
const glyphDefaults = {
	xstep: "auto",
};

class Glyph extends Storable {
	constructor(charCode, variant) {
		super(`glyph_${variant.index}_${charCode}`, {
			...glyphDefaults,
			buffer: new Array(256).fill(0),
		});
		this.variant = variant;
		this.charCode = charCode;
	}
}

export function init() {
	const font = new Font("MyFruityFont");
	if (!font.variants.length) {
		font.addVariant();
		font.variants[0].update({ ystep: 12, style: "Regular" });
	}
	return font;
}

export function wireInputs(container, object) {
	const inputs = container.querySelectorAll("input[data-prop]");
	const handleInput = (event) => {
		const value = event.target.value;
		const prop = event.target.dataset.prop;
		if (object.data[prop] !== value) object.update({ [prop]: value });
	};
	const handleChange = () => {
		for (const input of inputs) {
			const value = object.data[input.dataset.prop];
			if (input.value !== value) input.value = value;
			input.addEventListener("input", handleInput);
		}
	};

	object.addEventListener("change", handleChange);
	handleChange();
}

// "Packs" a font into a C file defining the data structures

const emptyPacketGlyph = { width: 0, height: 0, xpos: 0, ypos: 0, bitpos: 0 };

export function pack(font) {
	const { xmin, xmax, ymin, ymax, charfirst, charlast } = font.data;
	const cWidth = xmax - xmin + 1;
	const cHeight = ymax - ymin + 1;

	const buffers = [];
	const packedFonts = font.variants.map((variant, i) => {
		const { ystep, style } = variant.data;
		const packedGlyphs = variant.glyphs.map((glyph, j) => {
			const { charCode } = glyph;
			const { xstep: xAdv, buffer } = glyph.data;
			const { top, left, right, bottom, bytes } = getGlyphBytes(
				buffer,
				cWidth,
				cHeight,
			);

			if (right < left || bottom < top) {
				const xstep = xAdv === "auto" ? 1 : xAdv;
				return { ...emptyPacketGlyph, xstep, charCode };
			}

			buffers.push([bytes, i, j]);

			const width = right - left + 1;
			const height = bottom - top + 1;
			const xpos = left + xmin;
			const ypos = top - ymax + ystep;
			const xstep = xAdv === "auto" ? xpos + width + 1 : xAdv;

			return { width, height, xstep, xpos, ypos, charCode };
		});
		return { ystep, style, charfirst, charlast, packedGlyphs };
	});

	const { array, offsets } = packBitmaps(buffers);
	for (const [offset, i, j] of offsets) {
		packedFonts[i].packedGlyphs[j].bitpos = offset;
	}

	const name = font.data.name;
	const strs = [
		`/* ${name} generated by https://aravindet.github.io/fruitfont */\n`,
		`const uint8_t ${name}Bitmaps[] PROGMEM = { ${array
			.map(hex)
			.join(", ")} };\n`,
	];

	for (const { ystep, style, packedGlyphs } of packedFonts) {
		const vname = name + ystep + style;
		strs.push(`const GFXglyph ${vname}Glyphs[] PROGMEM = {`);
		strs.push(
			packedGlyphs
				.map(
					({ bitpos, width, height, xstep, xpos, ypos }) =>
						`\t{${[bitpos, width, height, xstep, xpos, ypos].join(", ")}}`,
				)
				.join(",\n"),
		);
		strs.push("};\n");
	}

	for (const { ystep, style, charfirst, charlast } of packedFonts) {
		const vname = name + ystep + style;
		strs.push(
			...[
				`const GFXfont ${vname} PROGMEM = {`,
				`\t(uint_t*) ${name}Bitmaps[], (GFXglyph*) ${vname}Glyphs,`,
				`\t${hex(charfirst)}, ${hex(charlast)}, ${ystep}`,
				"};",
			],
		);
	}

	const code = strs.join("\n");
	console.log(code);
	return `data:text/plain,${encodeURIComponent(code)}`;
}

function hex(num) {
	// rome-ignore lint/style/useTemplate:
	return "0x" + num.toString(16).padStart(2, "0");
}

function getIndex(x, y, width) {
	return y * width + x;
}

function isEdge(arr, start, stop, step) {
	for (let i = start; i <= stop; i += step) {
		if (arr[i]) return true;
	}
	return false;
}

function getGlyphBytes(arr, width, height) {
	let top = 0;
	let left = 0;
	let right = width;
	let bottom = height;

	let topFound = false;
	let leftFound = false;
	let rightFound = false;
	let bottomFound = false;

	while (
		!(topFound && leftFound && rightFound && bottomFound) &&
		bottom >= top &&
		right >= left
	) {
		const topLeft = getIndex(left, top, width);
		const topRight = getIndex(right, top, width);
		const bottomLeft = getIndex(left, bottom, width);
		const bottomRight = getIndex(right, bottom, width);

		topFound ||= isEdge(arr, topLeft, topRight, 1);
		leftFound ||= isEdge(arr, topLeft, bottomLeft, width);
		rightFound ||= isEdge(arr, topRight, bottomRight, width);
		bottomFound ||= isEdge(arr, bottomLeft, bottomRight, 1);

		if (!topFound) top++;
		if (!leftFound) left++;
		if (!rightFound) right--;
		if (!bottomFound) bottom--;
	}

	const binRows = [];
	for (let y = top; y <= bottom; y++) {
		const leftIx = getIndex(left, y, width);
		const rightIx = getIndex(right, y, width) + 1;
		binRows.push(arr.slice(leftIx, rightIx).join(""));
	}
	const binString = binRows.join("") + "0".repeat(7);
	const bytes = [];
	for (let i = 0; i < binString.length - 8; i += 8) {
		bytes.push(parseInt(binString.slice(i, i + 8), 2));
	}

	return { top, left, right, bottom, bytes };
}

function packBitmaps(buffers) {
	// TODO: Compression

	const array = [];
	const offsets = [];
	for (const [bytes, i, j] of buffers) {
		offsets.push([array.length, i, j]);
		array.push(...bytes);
	}
	return { array, offsets };
}
